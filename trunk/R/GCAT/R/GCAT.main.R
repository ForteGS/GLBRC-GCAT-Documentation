#Copyright 2012 The Board of Regents of the University of Wisconsin System.
#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, 
#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman
#
#This file is part of GCAT.
#
#GCAT is free software: you can redistribute it and/or modify
#it under the terms of the GNU Lesser General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#GCAT is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU Lesser General Public License for more details.
#
#You should have received a copy of the GNU Lesser General Public License  
#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.

# GCAT version 0.00
# Notes by Jason
# 08/18/2011

########################################################################
#                                                                      #
# Top-level functions for analysis of screening data from .csv files.  #
#                                                                      #
########################################################################
# This functions is called directly by the user interface.
# They in turn call the main function <gcat.fit.main> (below) multiple times for each data file provided in <file.list>.  

# Arguments:
# file.list - a list of full paths to .csv files. all files must be in the same format (see <single.plate>)
# single.plate - are the file in the single plate (wide) format vs. the multi-plate (long) format?
# layout.file - (optional) provide full path to a layout file with strain and media definitions (applies to all files in list)

# out.dir - name a directory to output the table of curve parameters to (defaults to working directory) 
# graphic.dir - name a directory to output the images of the fitted curves to (defaults to subdirectory "pics" of <out.dir> above)


# add.constant- should be a numeric constant that will be added to each curve before the log transform (defaults to 1) 
# blank.value - user can enter a blank OD measurement for uninoculated wells. if NULL, defaults to the value of the first OD measurement of each well. 
# start.index - which timepoint should be used as the first one after inoculation (defaults to the 2th one)
# growth.cutoff - minimum threshold for curve growth. 
# points.to.remove - a list of numbers referring to troublesome points that should be removed across all wells.
# remove.jumps - should the slope checking function be on the lookout for large jumps in OD?
  
# silent - should messages be returned to the console?
# verbose - should sub-functions return messages to console? (when I say verbose, I mean it!)

# Returns:
# if <return.fit> = F (default), avector of full paths to all the files generated by the function.
# otherwise, the fitted array of well objects. 

# Use this function to analyze any set of .csv files using the same plate layout info. 
gcat.analysis.main = function(file.list, single.plate, layout.file = NULL,   
  out.dir = getwd(), graphic.dir = paste(out.dir, "/pics", sep = ""), 
  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05,  
  points.to.remove = 0, remove.jumps = F, 
  silent = T, verbose = F, return.fit = F, overview.jpgs = T){
  
  suppressWarnings({ # Suppress console output (R "warnings" tend to result in errors downstream)
    upload.timestamp = strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S") # Get a timestamp for the time of upload.  
    fitted.well.array.master = list()
    source.file.list = c()
  
    dim(fitted.well.array.master) = c(plate.nrow,plate.ncol,0)
    dimnames(fitted.well.array.master) = list(PLATE.LETTERS[1:plate.nrow], 1:plate.ncol, c())
    
    for(file.name in file.list){
      
      # Call <gcat.fit.main> on the file with single plate options
    	fitted.well.array = try(gcat.fit.main(file.name = file.name, load.type = "csv",   
          single.plate = single.plate, layout.file = layout.file, start.index = start.index,  
          add.constant = add.constant, blank.value = blank.value, growth.cutoff = growth.cutoff,  
          points.to.remove = points.to.remove, remove.jumps = remove.jumps,
          silent = silent, verbose = verbose), silent = T)
      
      # Return error message if the function fails.
      if(class(fitted.well.array) == "try-error")
        return(as.character(fitted.well.array))  
    }
      
      # Add fitted well array onto existing fitted wells
      fitted.well.array.master = gcat.append.arrays(fitted.well.array.master, fitted.well.array)
      # Remove the "processed_" tag from file names and add to the list of source files.
      source.file.list = c(source.file.list, basename(paste(strsplit(file.name, "processed_")[[1]],collapse="/")))        

      out.files = try(gcat.output.main(fitted.well.array.master, out.prefix = "output", 
        source.file.list = source.file.list, upload.timestamp = upload.timestamp,   
        growth.cutoff = growth.cutoff, add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps, 
        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, 
        silent = silent), silent = T)
   # Return file list or error message
   # else 
  # Return "successful analysis" message (?)
  # file.list = c("Data was successfully analyzed.", file.list) # <--- yet to be implemented. causes errors downstream right now   
    if(class(out.files) == "try-error")
      return(as.character(out.files))     


    if(return.fit) return(fitted.well.array.master)
    else return(out.files)  
    })
  }

# OLD FUNCTION (will be deprecated when web server is rolled over):
#   Use this function for an xlsx file in multiple-plate format (robotic screening output)

multiple.plate.analysis = function(file.name, out.dir = getwd(), 
  graphic.dir = paste(out.dir, "/pics", sep = ""), layout.file = NULL, 
  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05, points.to.remove = 0, remove.jumps = F, 
  silent = T, verbose = F, return.fit = F, overview.jpgs = T){
  
  
  suppressWarnings({ # Suppress console output (R "warnings" tend to result in errors downstream)
  
    upload.timestamp = strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S") # Get a timestamp for the time of upload.  
    #gcat.set.constants(time.format = 24) # Set default constants
    # Call <gcat.fit.main> on the file with multiple plate options
    # Note: Using read.xlsx converts timestamps to number of days, so use <time.format> = 24
    fitted.well.array = try(gcat.fit.main(file.name = file.name, 
        load.type = "xlsx", single.plate = F, 
  			add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps,
        silent = silent, verbose = verbose),silent=T)
    
    # Return error message if the function fails. 
    if(class(fitted.well.array) == "try-error")
      return(as.character(fitted.well.array))
    
    # Remove the "processed_" tag from file names
    source.file = basename(paste(strsplit(file.name, "processed_")[[1]],collapse="/"))
   
    # Output to file
    out.prefix = strsplit(basename(source.file),"\\.")[[1]]
    # Erase the file extension of the source file.
    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=".") 
    
    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,  
        add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps, growth.cutoff = 0.05,
        out.dir = out.dir, graphic.dir = graphic.dir, 
        overview.jpgs=overview.jpgs, silent = silent),silent=T)
  
    # Return file list or error message
    if(class(file.list) == "try-error")
      return(as.character(file.list)) 
     # else 
     # Return "successful analysis" message (?)
     # file.list = c("Data was successfully analyzed.", file.list)
  
    if(return.fit) return(fitted.well.array)
    else return(file.list)   
    })
  }
  
  
# OLD FUNCTION (will be deprecated when web server is rolled over):
#  Use this function for an xlsx file in single-plate format (simple OD reader output)
single.plate.analysis = function(file.name, out.dir = getwd(), 
  graphic.dir = paste(out.dir, "/pics", sep = ""), layout.file = NULL,
  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05, points.to.remove = 0, remove.jumps = F, 
  silent = T, verbose = F, return.fit = F, overview.jpgs = T){
  
  suppressWarnings({ # Suppress console output (R "warnings" tend to result in errors downstream)
  
    upload.timestamp = strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S") # Get a timestamp for the time of upload.  
    #gcat.set.constants(time.format = 1/3600) # Set default constants
    # Call <gcat.fit.main> on the file with single plate options
  	fitted.well.array = try(gcat.fit.main(file.name = file.name,  
        load.type = "xlsx", single.plate = T,
        add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps,
        silent = silent, verbose = verbose), silent = T)
 
    # Return error message if the function fails.
    if(class(fitted.well.array) == "try-error")
      return(as.character(fitted.well.array))  
      
    # Remove the "processed_" tag from file names
    source.file = basename(paste(strsplit(file.name, "processed_")[[1]],collapse="/"))
   
    # Output to file
    out.prefix = strsplit(basename(source.file),"\\.")[[1]]
    # Erase the file extension of the source file.
    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=".") 
    
    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,   
        add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps, growth.cutoff = 0.05,
        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, 
        silent = silent), silent = T)
    
    # Return file list or error message
    if(class(file.list) == "try-error")
      return(as.character(file.list)) 
    # else 
    # Return "successful analysis" message (?)
    # file.list = c("Data was successfully analyzed.", file.list)
    
    if(return.fit) return(fitted.well.array)
    else return(file.list)  
    })
  }
  
# Use this function for any file format 
generic.plate.analysis = function(file.name, input.data = NULL, out.dir = getwd(), graphic.dir = paste(out.dir, "/pics", sep = ""), 
  load.type = "xlsx", single.plate = T, layout.file = NULL, plate.nrow = 8, plate.ncol = 12,  
  add.constant = 1, blank.value = NULL, start.index = 2, points.to.remove = c(2,3), remove.jumps = F, growth.cutoff = 0.05,   
  silent = T, verbose = F, return.fit = F, overview.jpgs = T){
  
  suppressWarnings({ # Suppress console output (R "warnings" tend to result in errors downstream)
  
      upload.timestamp = strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S") # Get a timestamp for the time of upload.  
      gcat.set.constants(plate.nrow = plate.nrow, plate.ncol = plate.ncol) # Set default constants
   
    # Call <gcat.fit.main> on the file with single plate options
    fitted.well.array = try(gcat.fit.main(file.name = file.name, layout.file = layout.file, input.data = input.data, 
        load.type = load.type, single.plate = single.plate,  
        add.constant = add.constant, blank.value = blank.value, start.index = start.index, growth.cutoff = growth.cutoff,  
        points.to.remove = points.to.remove, remove.jumps = remove.jumps,
        silent = silent, verbose = verbose), silent = T)
    
    # Return error message if the function fails.
    if(class(fitted.well.array) == "try-error")
      return(as.character(fitted.well.array))  
      
    # Remove the "processed_" tag from file names
    source.file = basename(paste(strsplit(file.name, "processed_")[[1]],collapse="/"))
   
    # Output to file
    out.prefix = strsplit(basename(source.file),"\\.")[[1]]
    # Erase the file extension of the source file.
    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=".") 
   
    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,  
        add.constant = add.constant, blank.value = blank.value, start.index = start.index, 
        points.to.remove = points.to.remove, remove.jumps = remove.jumps,
        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, 
        silent = silent), silent = T)
    
    # Return file list or error message
    if(class(file.list) == "try-error")
      return(as.character(file.list)) 
    # else 
    # Return "successful analysis" message (?)
    # file.list = c("Data was successfully analyzed.", file.list)
    
    if(return.fit) return(fitted.well.array)
    else return(file.list) 
    })  
  }

########################################################################
#                                                                      #
#   Main function for analysis of screening data from input tables.    #
#                                                                      #
########################################################################
# This is the main function that handles all the analyses for files in both single and multiple plate formats. 
# It is called by the top level function <analysis.main> 
# In turn, it loads the data into R using <load.xlsx> (if .xlsx file format) and <gcat.load.data>, resulting in an 
#   array of well objects (a class defined in <class.well.R>)
# It then calls the following functions on each member of the array: 
#    - curve normalization and standardization: <gcat.start.times>, <remove.points>, <normalize.ODs>, <transform.ODs>, 
#    - curve shape analysis before model fitting: <fill.slopes>, <check.curve>, <classify.curve>
#    - to fit a nonlinear model to the growth data: <fit.model>
# Finally, it returns the fitted array of well objects.

gcat.fit.main = function(file.name, input.data = NULL, load.type = "xlsx", layout.file = NULL, 
  single.plate = F, blank.value = NULL, start.index = 2, 
  normalize.method = "default", add.constant = 1, use.log = T, points.to.remove = 0,  
  fall.cutoff = -0.0025, growth.cutoff = 0.05, remove.jumps = F,  
  growth.model = richards, backup.growth.model = logistic, 
  silent = F, verbose = F){
  
  # Explanation of arguments:
  
  # ---File Handling---
  #   file.name - full path to an excel spreadsheet, .csv or tab-delimited text file, in either the single or multiple-plate format
  #   input.data - use pre-loaded data set (output from <gcat.load.data> function only). will override <file.name> if not NULL 
  #   load.type - supports "xlsx" and "csv." anything else will be read as a tab-delimited simple text file.  
  #   layout.file - full path to a file containing the plate layout in the same format as <file.name>. will not be used if <load.type> is "xlsx"

  # ---Input file format---
  #   single.plate - true denotes data in single-plate format, i.e. simple OD output. false denotes multiple-plate robotic screening output.  
  #      note: reading directly from excel to R results in timestamps being converted to days.

  # ---Normalization and Transforms---
  #  blank.value - user can enter a blank OD measurement for uninoculated wells. if NULL, defaults to the value of the first OD measurement of each well. 
  #  start.index - which timepoint should be used as the first one after inoculation (defaults to the 2th one)
  #  normalize.method - how should each growth curve be normalized? allowed values are:
  #     "first": subtracts the first OD, assumed to be the blank, from all ODs
  #     "none": does nothing, assumes no blank. highly recommend log(OD+1) transform in this case.
  #     "average.first": forces all filled wells on each plate to match the average value at <start.index> (after subtracting the first OD) 
  #  add.constant - a numeric constant that will be added to each curve before the log transform (defaults to 1)
  #  use.log - should a log transform be applied to the data after normalization? 
  #  points.to.remove - a list of numbers referring to troublesome points that should be removed across all wells.
  
  # ---Pre-fitting processing---
  #  fall.cutoff - a cutoff value for determining whether OD falls significantly between two timepoints. see <check.slopes> in prefit.processing.R for details. 
  #  growth.cutoff - a cutoff value for determining whether a well contains a successfully growing culture or not.
  #  remove.jumps - should the slope checking function be on the lookout for large jumps in OD?
  
  # ---Model fitting---
  #  model - which parametrized growth model to use? can be richards, gompertz, or logistic. models are defined as objects of class model, see "model.class.R"
  #  backup.model - which model should be used if fitting using <model> fails? should ideally be simpler than the main model (less parameters)
  
  # ---Miscellanous input/output preferences---
  #  silent - should messages be returned to the console?
  #  verbose - should sub-functions return messages to console? (when I say verbose, I mean it!) 
  #  unlog - should exported graphics be transformed back to the OD scale? 
  #  return.fit - should the function return an array of wells? if not, it will return a list of generated files.  
  
  	
  ########################################################################
  #    Read from .xlsx, .csv or tab-delimited text file                  #
  ########################################################################
  #
  # The functions used here are found in table2well.R and xlsx2well.R
  
  if(!silent) cat("\nReading input files...")
  
  if(load.type == "xlsx"){
    #  Read from multi-sheet excel file using <load.xlsx>
    #   if <layout.file> is provided, it will be ignored. 
  	well.array = try(load.xlsx(file.name = file.name, input.data = input.data, blank.value = blank.value, single.plate = single.plate, silent=silent),silent=silent)
   
    if (class(well.array) == "try-error")
    	stop("Error in <load.xlsx>: ", well.array)
  	}
  else{
    # Read from .csv or tab-delimited text file using <gcat.load.data> (in load.R)
    #   if <layout.file> is provided, it will be used here.  
    
    plate.layout = NULL          
    # Read layout file if it is specified. 
    if(!is.null(layout.file)){
      if(load.type=="csv") plate.layout = read.csv(layout.file,header=T,stringsAsFactors=F)
      else plate.layout = read.table(layout.file,header=T,sep="\t",stringsAsFactors=F)                                      
      if(!silent) cat("\n\tAdded plate layout information from", layout.file, "\n")
      }
      
    # Load the data    
		well.array = try(gcat.load.data(file.name = file.name, input.data = input.data, 
                      plate.layout = plate.layout,
                      blank.value = blank.value, single.plate = single.plate, 
                      load.type = load.type, silent=silent),silent=silent)

   # Return an error if there is a problem with file loading. 
    if (class(well.array) == "try-error")
    	stop("Error in <gcat.load.data>: ", well.array)
		}

  # !---At this point, <well.array> is an array of well objects, each containing raw data and media/strain information if provided--- 
  
  # Attempt to apply time formatting to all wells in array 
  well.array = try(aapply(well.array, gcat.start.times, start.index = start.index, time.format = time.format),silent=silent)
  
      # Return an error if there is a problem with time formatting
      if (class(well.array) == "try-error")
      	stop("Error in <gcat.start.times>: ", well.array)
  	
  ########################################################################
  #    Perform  normalization and transformation of raw data             #
  ########################################################################                                           
  #
  # The functions used here are found in normalize.and.transform.R 
  
  if(!silent) cat("\nProcessing raw data...")
  
  # Set all timepoints to active for now using "points.to.remove=0" argument with <remove.points> 
  #   adds an extra column to the "well.array" slot of each well specifying which points to remove when data is retrieved from the well
  well.array = aapply(well.array, remove.points, points = 0)
  
  # Remove specified timepoints across wells (use "points.to.remove=NULL" if no points to remove) 
  well.array = try(aapply(well.array, remove.points, points = points.to.remove),silent=silent)
      
      # Return an error if there is a problem with point removal
     if (class(well.array) == "try-error")
       stop("Error in <remove.points>: ", well.array)   
  
  # Normalize ODs using specified method and adding a constant if desired.  
  #   sets the "norm" slot of each well to a value to be subtracted from OD values whenever data is retrieved from the well
  well.array = try(normalize.ODs(well.array, normalize.method = normalize.method, 
    start.index = start.index, blank.value = blank.value, add.constant = add.constant),silent=silent)
  
      # Return an error if there is a problem with normalization
      if (class(well.array) == "try-error")
      	stop("Error in <normalize.ODs>: ", well.array)
  
  # Transform ODs on the logarithmic scale, regardless of whether <use.log> is true 
  #   an extra column of log-transformed values is added to the "well.array" slot of each well 
  #   the "use.log" slot of each well is set instead to determine whether the transformed values will be returned when data is retrieved from the well.
  well.array = try(aapply(well.array, transform.ODs, start.index = start.index, blank.value = blank.value, use.log = use.log, constant.added = add.constant),silent=silent)
  
      # Return an error if there is a problem with transformation
      if (class(well.array) == "try-error")
      	stop("Error in <transform.ODs>: ", well.array)
  

    
  ########################################################################
  #    Pre-fitting data processing (analysis of curve shapes)            #
  ########################################################################                                           
  #
  # The functions used here are found in slope.analysis.R
                               
  # Estimate slope at each timepoint 
  #  add a column to the "well.array" slot of each well with the local slope at each timepoint 
  
  well.array = try(aapply(well.array, calculate.slopes, silent=!verbose),silent=silent)
  
      # Return an error if there is a problem with slope calculation
      if (class(well.array) == "try-error")
      	stop("Error in <calculate.slopes>: ", well.array)
  
  # Check slopes for tanking and/or jumping behavior
  #  fills the "curve.par" slot of each well with <tanking.start>, denoting the timepoint at which tanking starts (if none, value is NA) 
  #  uses <remove.points> to remove all points after <tanking.start>
  #  It will also fill the "jump.error" slot with a status message, and try to use an automated process to remove the 
  #     erroneous points if <remove.jumps> is true (default false). 
    
  well.array = try(aapply(well.array, check.slopes, fall.cutoff = fall.cutoff, remove.jumps = remove.jumps, silent=!verbose, draw = F),silent=silent)
 
      # Return an error if there is a problem with slope analysis
      if (class(well.array) == "try-error")
      	stop("Error in <check.slopes>: ", well.array)
      	
      	
  # Check curves for growth above cutoff
  #   fills the "curve.par" slot of each well with <no.growth>, denoting whether the well has no detectable growth. 
  well.array = try(aapply(well.array, check.growth, growth.cutoff = growth.cutoff, start.index = start.index),silent=silent)
  
      # Return an error if there is a problem with growth.check
      if (class(well.array) == "try-error")
      	stop("Error in <check.growth>: ", well.array)
      	
  ########################################################################
  #           Fit parameterized models to data                           #
  ########################################################################                                           
  #
  # The functions used here are found in fit.model.R    
                                 
  # Fit each well with the selected model and attempt to catch failed fittings with the backup model 
  #   skips wells designated as <no.growth> above
  #   fills the "fit.info" slot of each well with "success," "failed," or "skipped"
  #   if fit was successful:
  #     fills the "equation" and "model.name" slots with the relevant info for the successful model 
  #     fills the "fit.par" slot with fitted parameters if fit is successful   
  
  if(!silent) cat("\nFitting models to data...")
  well.array = aapply(well.array, fit.model, growth.model=growth.model, backup.growth.model = backup.growth.model, silent=!verbose)
  
      # Return an error if there is a problem with model fitting
      if (class(well.array) == "try-error")
      	stop("Error in <fit.model>: ", well.array)
        
  if(!silent) cat("\ndone!\n")     
  return(well.array)     
  }    
  
  
########################################################################
#                                                                      #
#   Output function for generating files from fitted data.             #
#                                                                      #
########################################################################  
# Handles files and directories, calls <table.out>, <plate.overview> and <view.fit> to generate output tables and graphics.
#   out.dir - name a directory to output the table of curve parameters to (defaults to working directory) 
#   graphic.dir - name a directory to output the images of the fitted curves to (defaults to subdirectory "pics" of <out.dir> above)
#   overview.jpgs - should jpgs be generated for each plate with the overview graphic? this is for backwards compatibility with the old web server. 

# ---Miscellanous input/output preferences---
#  silent - should messages be returned to the console?
#  unlog - should exported graphics be transformed back to the OD scale?
#  constant.added (should be the same value as add.constant above) - used to readjust for the constant added during the log transform when plotting ODs. 

gcat.output.main = function(fitted.well.array, out.prefix = "", source.file.list, upload.timestamp = NULL,   
  add.constant, blank.value, start.index, growth.cutoff, points.to.remove, remove.jumps, 
  out.dir = getwd(), graphic.dir = paste(out.dir,"/pics",sep = ""), overview.jpgs = T,
  unlog = T, silent = T){     
  
  # Prepare timestamp for addition to output file names. 
  filename.timestamp = strftime(upload.timestamp, format="_%Y-%m-%d_%H.%M.%S")
    	
  ########################################################################
  #           Prepare to write to output files                           #
  ########################################################################                                            	
	 if(is.null(blank.value)) blank.value = "First timepoint in well"
	 
  if(!silent) cat("\nFinding/creating new output directories...")
   
  old.wd = getwd()  
  # Create output directory if it doesn't exist
  if(class(try(setwd(out.dir), silent = T)) == "try-error"){
  	if(!silent) cat("\ncreating new output directory")
  	if (class(try(dir.create(out.dir))) == "try-error")
  		stop("Error creating new output directory!")
  	}
  
  # Create graphics directory if it doesn't exist
  if(class(try(setwd(graphic.dir), silent = T)) == "try-error"){
  	if(!silent) cat("\ncreating new graphics directory")
  	if (class(try(dir.create(graphic.dir))) == "try-error")
  		stop("Error creating new graphics directory!")
  	}
  	
  ########################################################################
  #    Populate a data table with fit results and write to file          #
  ######################################################################## 
  #                                         
  # The functions used here are found in table.output.R 
                                 
  # Creates a table with a row for each well and a column for each of various identifiers and fitted and calculated parameters. 
  
  if(!silent) cat("\nPopulating data table...")
  table.fit = try(table.out(fitted.well.array, filename.timestamp=filename.timestamp))
  
      # Return an error if there is a problem with returning the table
      if (class(fitted.well.array) == "try-error")
      	stop("Error in <table.out>: ", fitted.well.array)
      	
 	
  # Set working directory to <out.dir>
	if (class(try(setwd(out.dir))) == "try-error")
		stop("Error setting directory for table output")
		
	# Write output table to file in <out.dir> 
  table.filename = paste(out.dir, "/", out.prefix, "_gcat.fit", filename.timestamp, ".txt", sep = "")
  if (class(try(write.table(table.fit, table.filename, sep = "\t", row.names = F))) == "try-error")
		stop("Error writing tabular output")
		
 	# ---If successfully written, add postscript and start a list of generated files.	
  generated.files = table.filename

  ########################################################################
  #    Write individual fit and overview graphics to file                #
  ######################################################################## 
  #                         
  # The functions used here are found in graphic.output.R
  
  if(!silent) cat("\nDrawing graphics...")
  
  # Set working directory to <graphic.dir>
	if (class(try(setwd(graphic.dir))) == "try-error")
		stop("Error setting directory for graphic output")
	# Use function <pdf.by.plate> to write fit graphics to file. 
  
	graphic.files = try(pdf.by.plate(fitted.well.array, out.prefix=out.prefix, upload.timestamp = upload.timestamp, 
    unlog=unlog,constant.added=add.constant,overview.jpgs=overview.jpgs),silent=silent)
  
  if (class(graphic.files) == "try-error")
		stop("Error in <pdf.by.plate>: ", graphic.files)
 
  # If successfully written, add to the list of generated files.	
  generated.files = c(generated.files, graphic.files)
  
  ########################################################################
  #    Add a postscript to the output table with legend and file info.   #
  ######################################################################## 
  #                           	
  sink(table.filename, append = T) 
  analysis.timestamp = strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S")
  cat("\n# -- Explanation of columns --",
      "\n#    - model: Name of the model the well was successfully fit with (if any)",
      "\n#    - spec.growth: (Specific growth rate) The largest exponential growth rate achieved by the culture in the course of the experiment", 
      "\n#    - tot.growth: (Total extrapolated growth) The estimated growth plateau from the fitted model in optical density units. May be higher than the actual highest OD reached.",
      "\n#    - lag.time: (Lag time) The exponential trend from <spec.growth> is extrapolated to the baseline OD at inoculation and subtracted from the time at inoculation to yield lag time.",
      "\n#    - inoc.OD: (OD at inoculation) The adjusted optical density at the user-specified starting timepoint.", 
      "\n#    - good.fit: (Goodness of fit) A metric based on root mean square deviations (RMSD).", 
      "\n#              - higher values ( > 3.0) indicate a very good fit while lower values (< 2.0) indicate generally unacceptable fits.",    
      "\n#    - empty: (Well indicator)", 
      "\n#              - an 'E' indicates that the well was empty and no growth was detected. ",
      "\n#              - an 'I' indicates that the well was inoculated and growth was detected above the threshold. ",
      "\n#              - an 'E*' indicates that the well was empty and growth was detected (possible contamination). ",
      "\n#              - an '!' indicates that the well was inoculated and no growth was detected. ",
      "\n#    - tank: (Tanking indicator) If a number is present then the growth trend was determined to tank at that timepoint index.", 
      "\n#    - reach: (Final growth percentage): The percentage of <tot.growth> reached by the culture in the course of the experiment.", 
      "\n#    - other: Other information includes output from jump detection algorithm and additional columns from the Plate Layout.",
      "\n#    - pdf.file and page.no: location of the figure for this well in the output .pdf files.")
	 # Analysis information

   cat("\n#\n# -- Source file information--",
      "\n# ",  paste(source.file.list, collapse = "\n# "), 
      "\n#  analyzed using GCAT v", global.version.number,  
      "\n#  request sent: ", upload.timestamp, 
      "\n#  completed: ", analysis.timestamp, 
      "\n#\n# -- Parameters used in current analysis --",
      "\n#    - Constant added to log(OD + n) transformation:", add.constant,
      "\n#    - Blank OD value: ", blank.value,
      "\n#    - Index of inoculation timepoint", start.index,
      "\n#    - Minimum growth threshold:", growth.cutoff, 
      "\n#    - Removed points:", paste(points.to.remove, collapse = " "),
      "\n#    - Jump detection:", remove.jumps) 
  sink()
  
  ########################################################################
  #                 Return values to R                                   #
  ######################################################################## 
  #  

  if(!silent) cat("\ndone!")                    
  setwd(old.wd)
  # Return list of generated files
	return(generated.files)
  }
  
