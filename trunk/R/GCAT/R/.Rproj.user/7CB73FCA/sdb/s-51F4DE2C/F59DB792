{
    "contents" : "#Copyright 2012 The Board of Regents of the University of Wisconsin System.\n#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, \n#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman\n#\n#This file is part of GCAT.\n#\n#GCAT is free software: you can redistribute it and/or modify\n#it under the terms of the GNU Lesser General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n#\n#GCAT is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU Lesser General Public License for more details.\n#\n#You should have received a copy of the GNU Lesser General Public License  \n#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.\n\n########################################################################\n#                                                                      #\n# Functions to calculate various things about wells based on fit model #\n#                                                                      #\n########################################################################\n#\n#  Common arguments:\n#   fitted.well - should be a well containing the results of <fit.model>, most functions will return NA if well has not been fit yet.\n#   unlog - should the value be returned on the linear scale as opposed to the log-transformed scale?\n#   constant.added - for returning values on the linear scale, what was the constant added before the log transform?\n#   digits - passed to the <round> function, default is no rounding (infinity digits)\n\nwell.eval = function(fitted.well, Time = NULL, unlog = T, constant.added = 0){\n  ########################################################################\n  #   Evaluate estimated OD at any timepoints using the fitted model     #\n  ########################################################################\n\n  # If no timepoints are provided, use the ones collected in the experiment itself.\n\tif(!is.numeric(Time))\n\t\tTime = data.from(fitted.well)$Time\n\n  # Attempt to use <eval> with the fitted equation and parameters to get estimates for OD at the given timepoints.\n\toutput = try(eval(fitted.well@equation, fitted.well@fit.par), silent = T)\n\n  # Return values on log scale or linear scale. If OD evaluation failed for any reason, return NULL.\n  if (is.numeric(output)){\n    if(unlog)\n  \t\treturn(exp(output) - constant.added)\n  \telse\n  \t\treturn(output)\n    }\n   else\n    return(NULL)\n\t}\n\nmodel.residuals = function(fitted.well, unlog = F){\n  ########################################################################\n  #   Evaluate model residuals using the measured vs. fitted OD values   #\n  ########################################################################\n  # Get measured OD values from well using normal or log scale\n  if (unlog)\n\t\tfitted.well@use.log = F\n\telse\n\t\tfitted.well@use.log = T\n\tmeasured.OD = data.from(fitted.well)[,2]\n\n\t# Use <well.eval> with no Time argument to get fitted OD values at measured timepoints.\n\tpredicted.OD = well.eval(fitted.well, unlog = unlog)\n\n\t# If all values are valid, return the differences\n\tif (!is.numeric(predicted.OD))\n\t\treturn(NA)\n\telse\n    return(measured.OD - predicted.OD)\n\t}\n\n\nmodel.good.fit = function(fitted.well, digits = Inf, unlog = F){\n  ########################################################################\n  #   Calculate a metric for fit accuracy using squared residuals        #\n  ########################################################################\n\n  # Sum of squared residuals\n\trss = sum(model.residuals(fitted.well)^2, unlog = unlog)\n\n\tif (unlog)\n\t\tfitted.well@use.log = F\n\telse\n\t\tfitted.well@use.log = T\n\n  # Variance in x and y of the measured timepoints\n\tvarx = var(data.from(fitted.well)[,1])\n\tvary = var(data.from(fitted.well)[,2])\n\n  # Negative log(10) of the residual sum of squares divided by variance on either axis.\n\treturn(round(-log10(rss/varx/vary),digits = digits))\n\t}\n\nparameter.text = function(fitted.well){\n  ########################################################################\n  #           Output a string with values of fitted parameters           #\n  ########################################################################\n\n  # Get a list of fitted parameters\n  fit.par = fitted.well@fit.par\n\n  # Return nothing if the list is empty. Otherwise, concatenate the terms in the list with the parameter names.\n\tif(!is.list(fit.par))\n\t\treturn()\n  else{\n  \toutput = \"\"\n  \ti = 1\n  \twhile(i <= length(fit.par)){\n  \t\toutput = paste(output, names(fit.par)[i], \"=\", round(as.numeric(fit.par[i]),3), \"; \", sep = \"\")\n  \t\ti = i + 1\n  \t\t}\n  \toutput\n  \t}\n\t}\n\nspecific.growth = function(fitted.well, digits = Inf){\n  ########################################################################\n  #        Calculate specific growth from fitted parameters              #\n  ########################################################################\n\n  # If there are no fitted OD values, return NA\n  if (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n\n\tTime = fitted.well@fit.par$t50\n\n  # If the timepoint at which maximum specific growth was reached according to fitted model was before inoculation, also return NA\n\tif (Time < 0)\n\t\treturn(NA)\n\n  # Evalute the derivative of the model equation with respect to time, at t50 (maximum slope)\n\tslope.max = eval(deriv(fitted.well@equation, \"Time\"), fitted.well@fit.par)\n\tslope.max = attr(slope.max, \"gradient\")\n\n  # Return the maximum slope, rounded as specified by <digits> (default: do not round)\n\tif(is.nan(slope.max[1]) | is.na(slope.max[1]))\n\t\treturn(NA)\n\telse\n\t\treturn(round(slope.max[1], digits))\n\t}\n\n\nplateau = function(fitted.well, unlog = T, constant.added = 1.0, digits = Inf){\n  ########################################################################\n  #        Calculate plateau OD from fitted parameters                   #\n  ########################################################################\n\n\tplat = fitted.well@fit.par$b\n\tif (!is.numeric(plat))\n\t\tplat = NA\n\telse{\n    if(!unlog)\n\t\t  plat = round(plat, digits)\n    else\n\t\t  plat = round(exp(plat) - constant.added, digits)\n\t\t}\n\treturn(plat)\n\t}\n\nbaseline = function(fitted.well, unlog = T, constant.added = 1.0, digits = Inf){\n  ########################################################################\n  #        Calculate baseline OD from fitted parameters                  #\n  ########################################################################\n\n  base = fitted.well@fit.par$a\n\n  # If b (plateau OD) is invalid, return NA.\n\tif (!is.numeric(fitted.well@fit.par$b))\n\t\tbase = NA\n  # If a (baseline OD) is invalid but plateau OD was valid, return zero.\n  else if (!is.numeric(base))\n\t\tbase = 0\n\telse{\n    if(!unlog)\n\t\t  base = round(base, digits)\n    else\n\t\t  base = round(exp(base) - constant.added, digits)\n\t\t}\n\treturn(base)\n\t}\n\n\n\ninoc.OD = function(fitted.well, unlog = T, constant.added = 1.0, digits = Inf){\n  ########################################################################\n  #        Calculate OD at inoculation from fitted parameters            #\n  ########################################################################\n\n  # Evaluated the fitted model at the inoculation timepoint (should be zero from using <start.times> from table2wells.R)\n\tif (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n  else{\n    return(round(well.eval(fitted.well, 0, unlog = unlog), digits) - constant.added)\n    }\n\t}\n\n\nend.OD = function(fitted.well, unlog = T, constant.added = 1.0, digits = Inf){\n  ########################################################################\n  #        Calculate OD at end of experiment from fitted parameters      #\n  ########################################################################\n\n  # Evaluated the fitted model at the final timepoint (just the last valid timepoint in the experiment)\n\tif (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n  else{\n  \ttime.fin = max(data.from(fitted.well)$Time)\n  \treturn(round(well.eval(fitted.well, time.fin, unlog = unlog), digits) - constant.added)\n    }\n  }\n\n\n  ########################################################################\n  #   Calculate total growth: plateau minus the inoculated OD            #\n  ########################################################################\n\ntotal.growth = function(fitted.well,...)\n\tplateau(fitted.well,...) - inoc.OD(fitted.well,...)\n\n\n\nreach.plateau = function(fitted.well, cutoff = 0.75, unlog = T){\n  ########################################################################\n  # Did the curve come close to the plateau OD during the experiment?    #\n  ########################################################################\n\n  plat = plateau(fitted.well, unlog=unlog)\n  inoc = inoc.OD(fitted.well, unlog=unlog)\n  final = end.OD(fitted.well, unlog=unlog)\n\n\tif (!is.na(final)){\n    # If the plateau is the same as the OD at inoculation, return TRUE\n    if ((plat - inoc) == 0)\n      return(T)\n     # If the difference between the final OD and inoculation OD is at least a certain proportion\n     #  <cutoff> of the difference between the plateau and inoculated ODs, return TRUE.\n    else\n      return((final - inoc) / (plat - inoc) > cutoff)\n\t\t}\n\telse\n\t\treturn(T)\n\t\t# If no final OD was calculated (if curve was not fit properly) just return T.\n\t}\n\n\nlag.time = function(fitted.well, digits = Inf){\n  ########################################################################\n  #              Calculate the lag time from the fitted OD               #\n  ########################################################################\n\n  # Return NA if the well has no fitted OD values or a specific growth could not be calculated.\n  if (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n\tmax.slope = specific.growth(fitted.well)\n\tif (is.na(max.slope))\n\t\treturn(0)\n\n  # Get the inoculated, transformed OD from the well (use 0 if it could not be calculated).\n\tinoc = inoc.OD(fitted.well, unlog = F, constant.added=0)\n\tif (!is.numeric(inoc))\n\t\tinoc = 0\n\n  # Evaluate OD at the point of maximum slope\n  x = fitted.well@fit.par$t50\n\ty = well.eval(fitted.well, x, unlog = F)\n\n  # Calculate lag time by extending the tangent line from the point of maximum slope (in the log-transformed data)\n  #  and calculating the time at the intercept with OD at inoculation, then subtracting the time at inoculation.\n\n\toutput = x - (y - inoc) / max.slope\n\n  # If the calculation returned an erroneous or negative value, return zero.\n\tif(is.nan(output) | is.na(output))\n\t\treturn(0)\n\tif (output < 0)\n\t\treturn(0)\n\telse\n    return(round(output, digits))\n\t}\n\n\n\n",
    "created" : 1398097372185.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3151632669",
    "id" : "F59DB792",
    "lastKnownWriteTime" : 1397767472,
    "path" : "~/Documents/GCAT/trunk/R/GCAT/R/fitted.calculations.R",
    "project_path" : "fitted.calculations.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}