{
    "contents" : "#Copyright 2012 The Board of Regents of the University of Wisconsin System.\n#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, \n#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman\n#\n#This file is part of GCAT.\n#\n#GCAT is free software: you can redistribute it and/or modify\n#it under the terms of the GNU Lesser General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n#\n#GCAT is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU Lesser General Public License for more details.\n#\n#You should have received a copy of the GNU Lesser General Public License  \n#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.\n\n########################################################################\n#                                                                      #\n# Populate an output table with parameters and other useful info for   #\n#   each well in a fitted dataset.                                     #\n#                                                                      #\n########################################################################\n#\n# unlog - Should OD values be returned on the linear scale instead of log-transformed scale? \n# constant.added - For returning values on linear scale, what constant was added to ODs before the log transform? \n# reach.cutoff - what proportion of the plateau OD must tbe reached by the last valid timepoint for the curve to be marked as reaching its plateau OD?\n#\n\ntable.out = function(fitted.data.set, unlog = T, constant.added = 1.0, reach.cutoff = 0.90, filename.timestamp = NULL){\n\n  # The idea is basically to use <unlist> and <aapply> on the fitted data array in order \n  # to get one vector for each column of the output table.  \n\n  # Get identifying information (plate, well, media and strain names)\n\tplate.ID = unlist(aapply(fitted.data.set,plate.name))\n  well.ID = unlist(aapply(fitted.data.set,well.name))\n\tmedia.ID = unlist(aapply(fitted.data.set,media.name))\n\tstrain.ID = unlist(aapply(fitted.data.set,strain.name))\n\n\t# Get fit information for each well\n  #   - was it marked as empty in the plate layout?\n  #   - did the program find it to contain no growth (\"dead\")? \n  #   - was the fitting procedure successful? \n  #   - did the curve tank? if so, at what timepoint? if not, set value to \"-\"\n    \n\tempty = unlist(aapply(fitted.data.set, is.empty))\n\tdead  = unlist(aapply(fitted.data.set, lacks.growth))\n\tfit = unlist(aapply(fitted.data.set, contains.fit))\n\ttanking = unlist(aapply(fitted.data.set, tanking.start))\n\ttanking[is.na(tanking) | tanking == 1 | dead] = \"-\"\n\n  # Get calculated values for each well: specific growth, final and initial OD, fitted plateau and baseline OD, lag time. \n\tspec.growth = unlist(aapply(fitted.data.set, specific.growth))\n\tfin.growth = unlist(aapply(fitted.data.set, end.OD, unlog = unlog))\n\tinit.growth = unlist(aapply(fitted.data.set, inoc.OD, unlog = unlog))\n\ttot.growth = unlist(aapply(fitted.data.set, total.growth, unlog = unlog))\n  lag.times = unlist(aapply(fitted.data.set, lag.time))\n  \n\tplateau.OD = unlist(aapply(fitted.data.set, plateau, unlog = unlog))\n\tbaseline.OD = unlist(aapply(fitted.data.set, baseline, unlog = unlog))\n\n  # If the curve falls short of 90% of plateau OD by the final timepoint.\n\tno.reach.plateau = !unlist(aapply(fitted.data.set, reach.plateau, unlog = unlog, cutoff = 0.9))\n\t# If the fitted baseline is below zero on the linear scale. \n  no.reach.baseline = baseline.OD < 0\n\t\n  # If any of these are NA as a result of failed fits, change them to false: they don't need to be reported.  \n\tno.reach.plateau[is.na(no.reach.plateau)] = F\n\tno.reach.baseline[is.na(no.reach.baseline)] = F\n\t\n\t# What percent of the total growth does the curve actually reach? \n  # (in case of total growth being 0, change this to 100%)\n\tpercent.reach = 100*(fin.growth - init.growth) / tot.growth\n  percent.reach[is.infinite(percent.reach)] = 100\n\n  # Return the name of the model (if any) that was successfully fit to the well. \n\tmodel.used = unlist(aapply(fitted.data.set, function(well)well@model.name))\n\n\t# \"Goodness of fit\" metric\n\tgood.fit = unlist(aapply(fitted.data.set, model.good.fit, unlog = F))\n\t\n\t# Code the two flags: \n \tflag1 = flag2 = rep(\"-\", length(tanking))\n\n\tfor(i in 1:length(tanking)){\t\n  \t#  Flag 1 (empty/inoculated flag) possible values:\n    #   well was empty and no growth was found (E)\n    #   well was empty, but growth was found (E*)\n    #   well was inoculated but no growth was found (!)\n    #   well was inoculated and growth was found (I)\n    \n\t\tif(empty[i] & !fit[i])\n\t\t\tflag1[i] = \"E \"\n\t\tif(empty[i] & fit[i])\n\t\t\tflag1[i] = \"E*\"\n\t\tif(!empty[i] & dead[i])\n\t\t\tflag1[i] = \"! \"\n\t\tif(!empty[i] & !dead[i])\n\t\t\tflag1[i] = \"I \"\n\n\t#  Flag 2 (lower/upper asymptotes) possible values:\n  #   well did not reach lower asymptote (baseline OD) (L)\n  #   well did not reach upper asymptote (plateau OD) (U)\n  #   well did not reach either asymptote (L/U)\n  #   well reached both asymptotes (-)\n                                                      \n\t\tif(no.reach.baseline[i]){\n\t\t\tif (no.reach.plateau[i])\n\t\t\t\tflag2[i] = \"L/U\"\n\t\t\telse\n\t\t\t\tflag2[i] = \"L\"\n\t\t\t}\n\t\telse{\n\t\t\tif (no.reach.plateau[i])\n\t\t\t\tflag2[i] = \"U\"\n\t\t\telse\n\t\t\t\tflag2[i] = \"-\"\n      }\n    # Also use the <dead> and <empty> and <fit> to provie more info about why model fitting failed in some cases. \n    if(dead[i])\n      model.used[i] = \"<NA>: skipped\"\n    else if(!empty[i] & !fit[i])\n    \tmodel.used[i] = \"<NA>: failed\"\t\n\t\t}\n    \n  # Flag 3: return the additional info slot. \n  flag3 = unlist(aapply(fitted.data.set, function(well){\n    if (length(well@add.info) > 0) \n      return(well@add.info)\n    else\n      return(\"\")\n    }))\n\n    # If something is amiss with the data table use this to check on the arguments...\n    #cat(\"plate \", length(plate.ID),\" well \", length(well.ID),\" media \", length(media.ID),\" strain \", length(strain.ID),\n    #\" model \", length(model.used),\" spec.growth\", length(spec.growth), \"tot.growth\", length(tot.growth),\n    #\"lag.time\", length(lag.times), \"inoc.OD\", length(init.growth), \"good.fit\",\n    #length(good.fit),\"empty\", length(flag1),\"asymp\", length(flag2),\" tank \", length(tanking),\" reach \", length(percent.reach),\" other \", length(flag3), sep = \"\\n\")\n\n  # 06.28.11: Add a row number identifier for output perusal\n  row.number = 1:length(plate.ID)\n\n  pdf.file = page.no = c()\n  # 06.29.11: Add pdf file name and page number references. Prepare timestamp for addition to output file names (for file references in last column)\n  for(i in 1:length(plate.ID)){\n    pdf.file[i] = paste(plate.ID[i], \"_plots\", filename.timestamp, \".pdf\", sep=\"\")\n    page.no[i] = (i-1) %% 96 + 2\n    }\n\n\t# Slap it all together into a data frame.\n\toutput.core = data.frame(row = row.number, plate = plate.ID, well = well.ID, media = media.ID, strain = strain.ID, \n    model = model.used, spec.growth, tot.growth, lag.time = lag.times, inoc.OD = init.growth,   \n\t\tgood.fit, empty = flag1, asymp = flag2, tank = tanking, reach = percent.reach, other = flag3, pdf.file, page.no)\n  \n  \n\n  # Add on any additional fields found in the plate layout. \n  all.layout.fields = sapply(fitted.data.set, function(well) unlist(well@well.info)) \n  all.layout.fields = as.data.frame(t(all.layout.fields))\n  \n  \n  addl.info = all.layout.fields[,!(names(all.layout.fields) %in% c(\"Strain\", \"Media\"))]\n  if(!is.data.frame(addl.info)){\n    addl.info = data.frame(addl.info)\n    names(addl.info) = names(all.layout.fields)[!(names(all.layout.fields) %in% c(\"Strain\", \"Media\"))] \n    }\n  \n  output = cbind(output.core,addl.info)\n  \n  return(output)\n}\n\n\n\n\n\n\n",
    "created" : 1398096531514.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1833782531",
    "id" : "C1C3B473",
    "lastKnownWriteTime" : 1397767472,
    "path" : "~/Documents/GCAT/trunk/R/GCAT/R/table.output.R",
    "project_path" : "table.output.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}