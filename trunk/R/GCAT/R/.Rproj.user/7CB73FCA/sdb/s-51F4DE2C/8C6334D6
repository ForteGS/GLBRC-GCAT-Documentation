{
    "contents" : "#Copyright 2012 The Board of Regents of the University of Wisconsin System.\n#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, \n#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman\n#\n#This file is part of GCAT.\n#\n#GCAT is free software: you can redistribute it and/or modify\n#it under the terms of the GNU Lesser General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n#\n#GCAT is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU Lesser General Public License for more details.\n#\n#You should have received a copy of the GNU Lesser General Public License  \n#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.\n\n# GCAT version 0.00\n# Notes by Jason\n# 08/18/2011\n\n########################################################################\n#                                                                      #\n# Top-level functions for analysis of screening data from .csv files.  #\n#                                                                      #\n########################################################################\n# This functions is called directly by the user interface.\n# They in turn call the main function <gcat.fit.main> (below) multiple times for each data file provided in <file.list>.  \n\n# Arguments:\n# file.list - a list of full paths to .csv files. all files must be in the same format (see <single.plate>)\n# single.plate - are the file in the single plate (wide) format vs. the multi-plate (long) format?\n# layout.file - (optional) provide full path to a layout file with strain and media definitions (applies to all files in list)\n\n# out.dir - name a directory to output the table of curve parameters to (defaults to working directory) \n# graphic.dir - name a directory to output the images of the fitted curves to (defaults to subdirectory \"pics\" of <out.dir> above)\n\n\n# add.constant- should be a numeric constant that will be added to each curve before the log transform (defaults to 1) \n# blank.value - user can enter a blank OD measurement for uninoculated wells. if NULL, defaults to the value of the first OD measurement of each well. \n# start.index - which timepoint should be used as the first one after inoculation (defaults to the 2th one)\n# growth.cutoff - minimum threshold for curve growth. \n# points.to.remove - a list of numbers referring to troublesome points that should be removed across all wells.\n# remove.jumps - should the slope checking function be on the lookout for large jumps in OD?\n  \n# silent - should messages be returned to the console?\n# verbose - should sub-functions return messages to console? (when I say verbose, I mean it!)\n\n# Returns:\n# if <return.fit> = F (default), avector of full paths to all the files generated by the function.\n# otherwise, the fitted array of well objects. \n\n# Use this function to analyze any set of .csv files using the same plate layout info. \ngcat.analysis.main = function(file.list, single.plate, layout.file = NULL,   \n  out.dir = getwd(), graphic.dir = paste(out.dir, \"/pics\", sep = \"\"), \n  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05,  \n  points.to.remove = 0, remove.jumps = F, \n  silent = T, verbose = F, return.fit = F, overview.jpgs = T){\n  \n  suppressWarnings({ # Suppress console output (R \"warnings\" tend to result in errors downstream)\n    upload.timestamp = strftime(Sys.time(), format=\"%Y-%m-%d %H:%M:%S\") # Get a timestamp for the time of upload.  \n    fitted.well.array.master = list()\n    source.file.list = c()\n  \n    dim(fitted.well.array.master) = c(plate.nrow,plate.ncol,0)\n    dimnames(fitted.well.array.master) = list(PLATE.LETTERS[1:plate.nrow], 1:plate.ncol, c())\n    \n    for(file.name in file.list){\n      \n      # Call <gcat.fit.main> on the file with single plate options\n    \tfitted.well.array = try(gcat.fit.main(file.name = file.name, load.type = \"csv\",   \n          single.plate = single.plate, layout.file = layout.file, start.index = start.index,  \n          add.constant = add.constant, blank.value = blank.value, growth.cutoff = growth.cutoff,  \n          points.to.remove = points.to.remove, remove.jumps = remove.jumps,\n          silent = silent, verbose = verbose), silent = T)\n      \n      # Return error message if the function fails.\n      if(class(fitted.well.array) == \"try-error\")\n        return(as.character(fitted.well.array))  \n    }\n      \n      # Add fitted well array onto existing fitted wells\n      fitted.well.array.master = gcat.append.arrays(fitted.well.array.master, fitted.well.array)\n      # Remove the \"processed_\" tag from file names and add to the list of source files.\n      source.file.list = c(source.file.list, basename(paste(strsplit(file.name, \"processed_\")[[1]],collapse=\"/\")))        \n\n      out.files = try(gcat.output.main(fitted.well.array.master, out.prefix = \"output\", \n        source.file.list = source.file.list, upload.timestamp = upload.timestamp,   \n        growth.cutoff = growth.cutoff, add.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps, \n        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, \n        silent = silent), silent = T)\n   # Return file list or error message\n   # else \n  # Return \"successful analysis\" message (?)\n  # file.list = c(\"Data was successfully analyzed.\", file.list) # <--- yet to be implemented. causes errors downstream right now   \n    if(class(out.files) == \"try-error\")\n      return(as.character(out.files))     \n\n\n    if(return.fit) return(fitted.well.array.master)\n    else return(out.files)  \n    })\n  }\n\n# OLD FUNCTION (will be deprecated when web server is rolled over):\n#   Use this function for an xlsx file in multiple-plate format (robotic screening output)\n\nmultiple.plate.analysis = function(file.name, out.dir = getwd(), \n  graphic.dir = paste(out.dir, \"/pics\", sep = \"\"), layout.file = NULL, \n  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05, points.to.remove = 0, remove.jumps = F, \n  silent = T, verbose = F, return.fit = F, overview.jpgs = T){\n  \n  \n  suppressWarnings({ # Suppress console output (R \"warnings\" tend to result in errors downstream)\n  \n    upload.timestamp = strftime(Sys.time(), format=\"%Y-%m-%d %H:%M:%S\") # Get a timestamp for the time of upload.  \n    #gcat.set.constants(time.format = 24) # Set default constants\n    # Call <gcat.fit.main> on the file with multiple plate options\n    # Note: Using read.xlsx converts timestamps to number of days, so use <time.format> = 24\n    fitted.well.array = try(gcat.fit.main(file.name = file.name, \n        load.type = \"xlsx\", single.plate = F, \n  \t\t\tadd.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps,\n        silent = silent, verbose = verbose),silent=T)\n    \n    # Return error message if the function fails. \n    if(class(fitted.well.array) == \"try-error\")\n      return(as.character(fitted.well.array))\n    \n    # Remove the \"processed_\" tag from file names\n    source.file = basename(paste(strsplit(file.name, \"processed_\")[[1]],collapse=\"/\"))\n   \n    # Output to file\n    out.prefix = strsplit(basename(source.file),\"\\\\.\")[[1]]\n    # Erase the file extension of the source file.\n    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=\".\") \n    \n    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,  \n        add.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps, growth.cutoff = 0.05,\n        out.dir = out.dir, graphic.dir = graphic.dir, \n        overview.jpgs=overview.jpgs, silent = silent),silent=T)\n  \n    # Return file list or error message\n    if(class(file.list) == \"try-error\")\n      return(as.character(file.list)) \n     # else \n     # Return \"successful analysis\" message (?)\n     # file.list = c(\"Data was successfully analyzed.\", file.list)\n  \n    if(return.fit) return(fitted.well.array)\n    else return(file.list)   \n    })\n  }\n  \n  \n# OLD FUNCTION (will be deprecated when web server is rolled over):\n#  Use this function for an xlsx file in single-plate format (simple OD reader output)\nsingle.plate.analysis = function(file.name, out.dir = getwd(), \n  graphic.dir = paste(out.dir, \"/pics\", sep = \"\"), layout.file = NULL,\n  add.constant = 1, blank.value = NULL, start.index = 2, growth.cutoff = 0.05, points.to.remove = 0, remove.jumps = F, \n  silent = T, verbose = F, return.fit = F, overview.jpgs = T){\n  \n  suppressWarnings({ # Suppress console output (R \"warnings\" tend to result in errors downstream)\n  \n    upload.timestamp = strftime(Sys.time(), format=\"%Y-%m-%d %H:%M:%S\") # Get a timestamp for the time of upload.  \n    #gcat.set.constants(time.format = 1/3600) # Set default constants\n    # Call <gcat.fit.main> on the file with single plate options\n  \tfitted.well.array = try(gcat.fit.main(file.name = file.name,  \n        load.type = \"xlsx\", single.plate = T,\n        add.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps,\n        silent = silent, verbose = verbose), silent = T)\n \n    # Return error message if the function fails.\n    if(class(fitted.well.array) == \"try-error\")\n      return(as.character(fitted.well.array))  \n      \n    # Remove the \"processed_\" tag from file names\n    source.file = basename(paste(strsplit(file.name, \"processed_\")[[1]],collapse=\"/\"))\n   \n    # Output to file\n    out.prefix = strsplit(basename(source.file),\"\\\\.\")[[1]]\n    # Erase the file extension of the source file.\n    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=\".\") \n    \n    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,   \n        add.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps, growth.cutoff = 0.05,\n        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, \n        silent = silent), silent = T)\n    \n    # Return file list or error message\n    if(class(file.list) == \"try-error\")\n      return(as.character(file.list)) \n    # else \n    # Return \"successful analysis\" message (?)\n    # file.list = c(\"Data was successfully analyzed.\", file.list)\n    \n    if(return.fit) return(fitted.well.array)\n    else return(file.list)  \n    })\n  }\n  \n# Use this function for any file format \ngeneric.plate.analysis = function(file.name, input.data = NULL, out.dir = getwd(), graphic.dir = paste(out.dir, \"/pics\", sep = \"\"), \n  load.type = \"xlsx\", single.plate = T, layout.file = NULL, plate.nrow = 8, plate.ncol = 12,  \n  add.constant = 1, blank.value = NULL, start.index = 2, points.to.remove = c(2,3), remove.jumps = F, growth.cutoff = 0.05,   \n  silent = T, verbose = F, return.fit = F, overview.jpgs = T){\n  \n  suppressWarnings({ # Suppress console output (R \"warnings\" tend to result in errors downstream)\n  \n      upload.timestamp = strftime(Sys.time(), format=\"%Y-%m-%d %H:%M:%S\") # Get a timestamp for the time of upload.  \n      gcat.set.constants(plate.nrow = plate.nrow, plate.ncol = plate.ncol) # Set default constants\n   \n    # Call <gcat.fit.main> on the file with single plate options\n    fitted.well.array = try(gcat.fit.main(file.name = file.name, layout.file = layout.file, input.data = input.data, \n        load.type = load.type, single.plate = single.plate,  \n        add.constant = add.constant, blank.value = blank.value, start.index = start.index, growth.cutoff = growth.cutoff,  \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps,\n        silent = silent, verbose = verbose), silent = T)\n    \n    # Return error message if the function fails.\n    if(class(fitted.well.array) == \"try-error\")\n      return(as.character(fitted.well.array))  \n      \n    # Remove the \"processed_\" tag from file names\n    source.file = basename(paste(strsplit(file.name, \"processed_\")[[1]],collapse=\"/\"))\n   \n    # Output to file\n    out.prefix = strsplit(basename(source.file),\"\\\\.\")[[1]]\n    # Erase the file extension of the source file.\n    out.prefix = paste(out.prefix[-length(out.prefix)],collapse=\".\") \n   \n    file.list = try(gcat.output.main(fitted.well.array, out.prefix = out.prefix, source.file =  source.file, upload.timestamp = upload.timestamp,  \n        add.constant = add.constant, blank.value = blank.value, start.index = start.index, \n        points.to.remove = points.to.remove, remove.jumps = remove.jumps,\n        out.dir = out.dir, graphic.dir = graphic.dir, overview.jpgs=overview.jpgs, \n        silent = silent), silent = T)\n    \n    # Return file list or error message\n    if(class(file.list) == \"try-error\")\n      return(as.character(file.list)) \n    # else \n    # Return \"successful analysis\" message (?)\n    # file.list = c(\"Data was successfully analyzed.\", file.list)\n    \n    if(return.fit) return(fitted.well.array)\n    else return(file.list) \n    })  \n  }\n\n########################################################################\n#                                                                      #\n#   Main function for analysis of screening data from input tables.    #\n#                                                                      #\n########################################################################\n# This is the main function that handles all the analyses for files in both single and multiple plate formats. \n# It is called by the top level function <analysis.main> \n# In turn, it loads the data into R using <load.xlsx> (if .xlsx file format) and <gcat.load.data>, resulting in an \n#   array of well objects (a class defined in <class.well.R>)\n# It then calls the following functions on each member of the array: \n#    - curve normalization and standardization: <gcat.start.times>, <remove.points>, <normalize.ODs>, <transform.ODs>, \n#    - curve shape analysis before model fitting: <fill.slopes>, <check.curve>, <classify.curve>\n#    - to fit a nonlinear model to the growth data: <fit.model>\n# Finally, it returns the fitted array of well objects.\n\ngcat.fit.main = function(file.name, input.data = NULL, load.type = \"xlsx\", layout.file = NULL, \n  single.plate = F, blank.value = NULL, start.index = 2, \n  normalize.method = \"default\", add.constant = 1, use.log = T, points.to.remove = 0,  \n  fall.cutoff = -0.0025, growth.cutoff = 0.05, remove.jumps = F,  \n  growth.model = richards, backup.growth.model = logistic, \n  silent = F, verbose = F){\n  \n  # Explanation of arguments:\n  \n  # ---File Handling---\n  #   file.name - full path to an excel spreadsheet, .csv or tab-delimited text file, in either the single or multiple-plate format\n  #   input.data - use pre-loaded data set (output from <gcat.load.data> function only). will override <file.name> if not NULL \n  #   load.type - supports \"xlsx\" and \"csv.\" anything else will be read as a tab-delimited simple text file.  \n  #   layout.file - full path to a file containing the plate layout in the same format as <file.name>. will not be used if <load.type> is \"xlsx\"\n\n  # ---Input file format---\n  #   single.plate - true denotes data in single-plate format, i.e. simple OD output. false denotes multiple-plate robotic screening output.  \n  #      note: reading directly from excel to R results in timestamps being converted to days.\n\n  # ---Normalization and Transforms---\n  #  blank.value - user can enter a blank OD measurement for uninoculated wells. if NULL, defaults to the value of the first OD measurement of each well. \n  #  start.index - which timepoint should be used as the first one after inoculation (defaults to the 2th one)\n  #  normalize.method - how should each growth curve be normalized? allowed values are:\n  #     \"first\": subtracts the first OD, assumed to be the blank, from all ODs\n  #     \"none\": does nothing, assumes no blank. highly recommend log(OD+1) transform in this case.\n  #     \"average.first\": forces all filled wells on each plate to match the average value at <start.index> (after subtracting the first OD) \n  #  add.constant - a numeric constant that will be added to each curve before the log transform (defaults to 1)\n  #  use.log - should a log transform be applied to the data after normalization? \n  #  points.to.remove - a list of numbers referring to troublesome points that should be removed across all wells.\n  \n  # ---Pre-fitting processing---\n  #  fall.cutoff - a cutoff value for determining whether OD falls significantly between two timepoints. see <check.slopes> in prefit.processing.R for details. \n  #  growth.cutoff - a cutoff value for determining whether a well contains a successfully growing culture or not.\n  #  remove.jumps - should the slope checking function be on the lookout for large jumps in OD?\n  \n  # ---Model fitting---\n  #  model - which parametrized growth model to use? can be richards, gompertz, or logistic. models are defined as objects of class model, see \"model.class.R\"\n  #  backup.model - which model should be used if fitting using <model> fails? should ideally be simpler than the main model (less parameters)\n  \n  # ---Miscellanous input/output preferences---\n  #  silent - should messages be returned to the console?\n  #  verbose - should sub-functions return messages to console? (when I say verbose, I mean it!) \n  #  unlog - should exported graphics be transformed back to the OD scale? \n  #  return.fit - should the function return an array of wells? if not, it will return a list of generated files.  \n  \n  \t\n  ########################################################################\n  #    Read from .xlsx, .csv or tab-delimited text file                  #\n  ########################################################################\n  #\n  # The functions used here are found in table2well.R and xlsx2well.R\n  \n  if(!silent) cat(\"\\nReading input files...\")\n  \n  if(load.type == \"xlsx\"){\n    #  Read from multi-sheet excel file using <load.xlsx>\n    #   if <layout.file> is provided, it will be ignored. \n  \twell.array = try(load.xlsx(file.name = file.name, input.data = input.data, blank.value = blank.value, single.plate = single.plate, silent=silent),silent=silent)\n   \n    if (class(well.array) == \"try-error\")\n    \tstop(\"Error in <load.xlsx>: \", well.array)\n  \t}\n  else{\n    # Read from .csv or tab-delimited text file using <gcat.load.data> (in load.R)\n    #   if <layout.file> is provided, it will be used here.  \n    \n    plate.layout = NULL          \n    # Read layout file if it is specified. \n    if(!is.null(layout.file)){\n      if(load.type==\"csv\") plate.layout = read.csv(layout.file,header=T,stringsAsFactors=F)\n      else plate.layout = read.table(layout.file,header=T,sep=\"\\t\",stringsAsFactors=F)                                      \n      if(!silent) cat(\"\\n\\tAdded plate layout information from\", layout.file, \"\\n\")\n      }\n      \n    # Load the data    \n\t\twell.array = try(gcat.load.data(file.name = file.name, input.data = input.data, \n                      plate.layout = plate.layout,\n                      blank.value = blank.value, single.plate = single.plate, \n                      load.type = load.type, silent=silent),silent=silent)\n\n   # Return an error if there is a problem with file loading. \n    if (class(well.array) == \"try-error\")\n    \tstop(\"Error in <gcat.load.data>: \", well.array)\n\t\t}\n\n  # !---At this point, <well.array> is an array of well objects, each containing raw data and media/strain information if provided--- \n  \n  # Attempt to apply time formatting to all wells in array \n  well.array = try(aapply(well.array, gcat.start.times, start.index = start.index, time.format = time.format),silent=silent)\n  \n      # Return an error if there is a problem with time formatting\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <gcat.start.times>: \", well.array)\n  \t\n  ########################################################################\n  #    Perform  normalization and transformation of raw data             #\n  ########################################################################                                           \n  #\n  # The functions used here are found in normalize.and.transform.R \n  \n  if(!silent) cat(\"\\nProcessing raw data...\")\n  \n  # Set all timepoints to active for now using \"points.to.remove=0\" argument with <remove.points> \n  #   adds an extra column to the \"well.array\" slot of each well specifying which points to remove when data is retrieved from the well\n  well.array = aapply(well.array, remove.points, points = 0)\n  \n  # Remove specified timepoints across wells (use \"points.to.remove=NULL\" if no points to remove) \n  well.array = try(aapply(well.array, remove.points, points = points.to.remove),silent=silent)\n      \n      # Return an error if there is a problem with point removal\n     if (class(well.array) == \"try-error\")\n       stop(\"Error in <remove.points>: \", well.array)   \n  \n  # Normalize ODs using specified method and adding a constant if desired.  \n  #   sets the \"norm\" slot of each well to a value to be subtracted from OD values whenever data is retrieved from the well\n  well.array = try(normalize.ODs(well.array, normalize.method = normalize.method, \n    start.index = start.index, blank.value = blank.value, add.constant = add.constant),silent=silent)\n  \n      # Return an error if there is a problem with normalization\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <normalize.ODs>: \", well.array)\n  \n  # Transform ODs on the logarithmic scale, regardless of whether <use.log> is true \n  #   an extra column of log-transformed values is added to the \"well.array\" slot of each well \n  #   the \"use.log\" slot of each well is set instead to determine whether the transformed values will be returned when data is retrieved from the well.\n  well.array = try(aapply(well.array, transform.ODs, start.index = start.index, blank.value = blank.value, use.log = use.log, constant.added = add.constant),silent=silent)\n  \n      # Return an error if there is a problem with transformation\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <transform.ODs>: \", well.array)\n  \n\n    \n  ########################################################################\n  #    Pre-fitting data processing (analysis of curve shapes)            #\n  ########################################################################                                           \n  #\n  # The functions used here are found in slope.analysis.R\n                               \n  # Estimate slope at each timepoint \n  #  add a column to the \"well.array\" slot of each well with the local slope at each timepoint \n  \n  well.array = try(aapply(well.array, calculate.slopes, silent=!verbose),silent=silent)\n  \n      # Return an error if there is a problem with slope calculation\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <calculate.slopes>: \", well.array)\n  \n  # Check slopes for tanking and/or jumping behavior\n  #  fills the \"curve.par\" slot of each well with <tanking.start>, denoting the timepoint at which tanking starts (if none, value is NA) \n  #  uses <remove.points> to remove all points after <tanking.start>\n  #  It will also fill the \"jump.error\" slot with a status message, and try to use an automated process to remove the \n  #     erroneous points if <remove.jumps> is true (default false). \n    \n  well.array = try(aapply(well.array, check.slopes, fall.cutoff = fall.cutoff, remove.jumps = remove.jumps, silent=!verbose, draw = F),silent=silent)\n \n      # Return an error if there is a problem with slope analysis\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <check.slopes>: \", well.array)\n      \t\n      \t\n  # Check curves for growth above cutoff\n  #   fills the \"curve.par\" slot of each well with <no.growth>, denoting whether the well has no detectable growth. \n  well.array = try(aapply(well.array, check.growth, growth.cutoff = growth.cutoff, start.index = start.index),silent=silent)\n  \n      # Return an error if there is a problem with growth.check\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <check.growth>: \", well.array)\n      \t\n  ########################################################################\n  #           Fit parameterized models to data                           #\n  ########################################################################                                           \n  #\n  # The functions used here are found in fit.model.R    \n                                 \n  # Fit each well with the selected model and attempt to catch failed fittings with the backup model \n  #   skips wells designated as <no.growth> above\n  #   fills the \"fit.info\" slot of each well with \"success,\" \"failed,\" or \"skipped\"\n  #   if fit was successful:\n  #     fills the \"equation\" and \"model.name\" slots with the relevant info for the successful model \n  #     fills the \"fit.par\" slot with fitted parameters if fit is successful   \n  \n  if(!silent) cat(\"\\nFitting models to data...\")\n  well.array = aapply(well.array, fit.model, growth.model=growth.model, backup.growth.model = backup.growth.model, silent=!verbose)\n  \n      # Return an error if there is a problem with model fitting\n      if (class(well.array) == \"try-error\")\n      \tstop(\"Error in <fit.model>: \", well.array)\n        \n  if(!silent) cat(\"\\ndone!\\n\")     \n  return(well.array)     \n  }    \n  \n  \n########################################################################\n#                                                                      #\n#   Output function for generating files from fitted data.             #\n#                                                                      #\n########################################################################  \n# Handles files and directories, calls <table.out>, <plate.overview> and <view.fit> to generate output tables and graphics.\n#   out.dir - name a directory to output the table of curve parameters to (defaults to working directory) \n#   graphic.dir - name a directory to output the images of the fitted curves to (defaults to subdirectory \"pics\" of <out.dir> above)\n#   overview.jpgs - should jpgs be generated for each plate with the overview graphic? this is for backwards compatibility with the old web server. \n\n# ---Miscellanous input/output preferences---\n#  silent - should messages be returned to the console?\n#  unlog - should exported graphics be transformed back to the OD scale?\n#  constant.added (should be the same value as add.constant above) - used to readjust for the constant added during the log transform when plotting ODs. \n\ngcat.output.main = function(fitted.well.array, out.prefix = \"\", source.file.list, upload.timestamp = NULL,   \n  add.constant, blank.value, start.index, growth.cutoff, points.to.remove, remove.jumps, \n  out.dir = getwd(), graphic.dir = paste(out.dir,\"/pics\",sep = \"\"), overview.jpgs = T,\n  unlog = T, silent = T){     \n  \n  # Prepare timestamp for addition to output file names. \n  filename.timestamp = strftime(upload.timestamp, format=\"_%Y-%m-%d_%H.%M.%S\")\n    \t\n  ########################################################################\n  #           Prepare to write to output files                           #\n  ########################################################################                                            \t\n\t if(is.null(blank.value)) blank.value = \"First timepoint in well\"\n\t \n  if(!silent) cat(\"\\nFinding/creating new output directories...\")\n   \n  old.wd = getwd()  \n  # Create output directory if it doesn't exist\n  if(class(try(setwd(out.dir), silent = T)) == \"try-error\"){\n  \tif(!silent) cat(\"\\ncreating new output directory\")\n  \tif (class(try(dir.create(out.dir))) == \"try-error\")\n  \t\tstop(\"Error creating new output directory!\")\n  \t}\n  \n  # Create graphics directory if it doesn't exist\n  if(class(try(setwd(graphic.dir), silent = T)) == \"try-error\"){\n  \tif(!silent) cat(\"\\ncreating new graphics directory\")\n  \tif (class(try(dir.create(graphic.dir))) == \"try-error\")\n  \t\tstop(\"Error creating new graphics directory!\")\n  \t}\n  \t\n  ########################################################################\n  #    Populate a data table with fit results and write to file          #\n  ######################################################################## \n  #                                         \n  # The functions used here are found in table.output.R \n                                 \n  # Creates a table with a row for each well and a column for each of various identifiers and fitted and calculated parameters. \n  \n  if(!silent) cat(\"\\nPopulating data table...\")\n  table.fit = try(table.out(fitted.well.array, filename.timestamp=filename.timestamp))\n  \n      # Return an error if there is a problem with returning the table\n      if (class(fitted.well.array) == \"try-error\")\n      \tstop(\"Error in <table.out>: \", fitted.well.array)\n      \t\n \t\n  # Set working directory to <out.dir>\n\tif (class(try(setwd(out.dir))) == \"try-error\")\n\t\tstop(\"Error setting directory for table output\")\n\t\t\n\t# Write output table to file in <out.dir> \n  table.filename = paste(out.dir, \"/\", out.prefix, \"_gcat.fit\", filename.timestamp, \".txt\", sep = \"\")\n  if (class(try(write.table(table.fit, table.filename, sep = \"\\t\", row.names = F))) == \"try-error\")\n\t\tstop(\"Error writing tabular output\")\n\t\t\n \t# ---If successfully written, add postscript and start a list of generated files.\t\n  generated.files = table.filename\n\n  ########################################################################\n  #    Write individual fit and overview graphics to file                #\n  ######################################################################## \n  #                         \n  # The functions used here are found in graphic.output.R\n  \n  if(!silent) cat(\"\\nDrawing graphics...\")\n  \n  # Set working directory to <graphic.dir>\n\tif (class(try(setwd(graphic.dir))) == \"try-error\")\n\t\tstop(\"Error setting directory for graphic output\")\n\t# Use function <pdf.by.plate> to write fit graphics to file. \n  \n\tgraphic.files = try(pdf.by.plate(fitted.well.array, out.prefix=out.prefix, upload.timestamp = upload.timestamp, \n    unlog=unlog,constant.added=add.constant,overview.jpgs=overview.jpgs),silent=silent)\n  \n  if (class(graphic.files) == \"try-error\")\n\t\tstop(\"Error in <pdf.by.plate>: \", graphic.files)\n \n  # If successfully written, add to the list of generated files.\t\n  generated.files = c(generated.files, graphic.files)\n  \n  ########################################################################\n  #    Add a postscript to the output table with legend and file info.   #\n  ######################################################################## \n  #                           \t\n  sink(table.filename, append = T) \n  analysis.timestamp = strftime(Sys.time(), format=\"%Y-%m-%d %H:%M:%S\")\n  cat(\"\\n# -- Explanation of columns --\",\n      \"\\n#    - model: Name of the model the well was successfully fit with (if any)\",\n      \"\\n#    - spec.growth: (Specific growth rate) The largest exponential growth rate achieved by the culture in the course of the experiment\", \n      \"\\n#    - tot.growth: (Total extrapolated growth) The estimated growth plateau from the fitted model in optical density units. May be higher than the actual highest OD reached.\",\n      \"\\n#    - lag.time: (Lag time) The exponential trend from <spec.growth> is extrapolated to the baseline OD at inoculation and subtracted from the time at inoculation to yield lag time.\",\n      \"\\n#    - inoc.OD: (OD at inoculation) The adjusted optical density at the user-specified starting timepoint.\", \n      \"\\n#    - good.fit: (Goodness of fit) A metric based on root mean square deviations (RMSD).\", \n      \"\\n#              - higher values ( > 3.0) indicate a very good fit while lower values (< 2.0) indicate generally unacceptable fits.\",    \n      \"\\n#    - empty: (Well indicator)\", \n      \"\\n#              - an 'E' indicates that the well was empty and no growth was detected. \",\n      \"\\n#              - an 'I' indicates that the well was inoculated and growth was detected above the threshold. \",\n      \"\\n#              - an 'E*' indicates that the well was empty and growth was detected (possible contamination). \",\n      \"\\n#              - an '!' indicates that the well was inoculated and no growth was detected. \",\n      \"\\n#    - tank: (Tanking indicator) If a number is present then the growth trend was determined to tank at that timepoint index.\", \n      \"\\n#    - reach: (Final growth percentage): The percentage of <tot.growth> reached by the culture in the course of the experiment.\", \n      \"\\n#    - other: Other information includes output from jump detection algorithm and additional columns from the Plate Layout.\",\n      \"\\n#    - pdf.file and page.no: location of the figure for this well in the output .pdf files.\")\n\t # Analysis information\n\n   cat(\"\\n#\\n# -- Source file information--\",\n      \"\\n# \",  paste(source.file.list, collapse = \"\\n# \"), \n      \"\\n#  analyzed using GCAT v\", global.version.number,  \n      \"\\n#  request sent: \", upload.timestamp, \n      \"\\n#  completed: \", analysis.timestamp, \n      \"\\n#\\n# -- Parameters used in current analysis --\",\n      \"\\n#    - Constant added to log(OD + n) transformation:\", add.constant,\n      \"\\n#    - Blank OD value: \", blank.value,\n      \"\\n#    - Index of inoculation timepoint\", start.index,\n      \"\\n#    - Minimum growth threshold:\", growth.cutoff, \n      \"\\n#    - Removed points:\", paste(points.to.remove, collapse = \" \"),\n      \"\\n#    - Jump detection:\", remove.jumps) \n  sink()\n  \n  ########################################################################\n  #                 Return values to R                                   #\n  ######################################################################## \n  #  \n\n  if(!silent) cat(\"\\ndone!\")                    \n  setwd(old.wd)\n  # Return list of generated files\n\treturn(generated.files)\n  }\n  \n",
    "created" : 1398101726568.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4008080320",
    "id" : "8C6334D6",
    "lastKnownWriteTime" : 1397767472,
    "path" : "~/Documents/GCAT/trunk/R/GCAT/R/GCAT.main.R",
    "project_path" : "GCAT.main.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}